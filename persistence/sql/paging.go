package sql

import (
	"context"

	"github.com/doug-martin/goqu/v9"
	"github.com/doug-martin/goqu/v9/exp"
	"github.com/samber/lo"

	"github.com/hadroncorp/geck/persistence"
	"github.com/hadroncorp/geck/persistence/criteria"
	"github.com/hadroncorp/geck/persistence/paging/pagetoken"
	"github.com/hadroncorp/geck/structs"
)

// PageTokens is a group of [pagetoken.Token](s) generated by [NewPageTokens].
type PageTokens struct {
	Next     *pagetoken.Token
	Previous *pagetoken.Token
}

// NewPageTokensParams are the parameters for [NewPageTokens].
type NewPageTokensParams[T any] struct {
	DB              *goqu.Database
	Table           string
	CursorName      string
	ResultSet       []T
	FieldTranslator *persistence.FieldTranslator
	Criteria        criteria.Criteria
	InitialSort     criteria.SortOperator
}

// NewPageTokens verifies if there are more pages to fetch (executes an extra query). If so,
// it will generate respective next and previous [pagetoken.Token](s).
func NewPageTokens[T any](ctx context.Context, params NewPageTokensParams[T]) (PageTokens, error) {
	startCursorIdx := 0
	endCursorIdx := len(params.ResultSet) - 1
	if params.Criteria.Sorting.Operator == criteria.SortDescending {
		startCursorIdx = len(params.ResultSet) - 1
		endCursorIdx = 0
	}
	startCursor := structs.GetStructValue(params.ResultSet[startCursorIdx], params.Criteria.Sorting.Field,
		structs.WithTag("db"))
	endCursor := structs.GetStructValue(params.ResultSet[endCursorIdx], params.Criteria.Sorting.Field,
		structs.WithTag("db"))
	hasPrev, hasNext, err := HasMorePages(ctx, HasMorePagesParams{
		DB:              params.DB,
		Table:           params.Table,
		CursorName:      params.CursorName,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
		FieldTranslator: params.FieldTranslator,
		Criteria:        params.Criteria,
	})
	if err != nil {
		return PageTokens{}, err
	}

	tokens := PageTokens{}
	if hasPrev {
		tokens.Previous = &pagetoken.Token{
			CursorName:  params.CursorName,
			StartCursor: startCursor,
			Sort: pagetoken.Sort{
				Field:    params.CursorName,
				Operator: criteria.SortDescending.String(),
			},
			InitialSortOperator: params.InitialSort.String(),
			Direction:           pagetoken.PreviousDirection,
		}
	}
	if hasNext {
		tokens.Next = &pagetoken.Token{
			CursorName: params.CursorName,
			EndCursor:  endCursor,
			Sort: pagetoken.Sort{
				Field:    params.CursorName,
				Operator: criteria.SortAscending.String(),
			},
			InitialSortOperator: params.InitialSort.String(),
			Direction:           pagetoken.NextDirection,
		}
	}
	return tokens, nil
}

// HasMorePagesParams are the parameters for [HasMorePages].
type HasMorePagesParams struct {
	DB              *goqu.Database
	Table           string
	CursorName      string
	StartCursor     any
	EndCursor       any
	Criteria        criteria.Criteria
	FieldTranslator *persistence.FieldTranslator
}

// HasMorePages performs a query to check if there are next and previous pages based on [HasMorePagesParams.CursorName].
func HasMorePages(ctx context.Context, params HasMorePagesParams) (hasPrev, hasNext bool, err error) {
	if params.CursorName == "" {
		return
	}

	if err = criteria.TranslateFields(params.FieldTranslator, &params.Criteria); err != nil {
		return false, false, err
	}
	params.CursorName = lo.CoalesceOrEmpty(params.FieldTranslator.Source[params.CursorName], params.CursorName)

	var expressionList exp.ExpressionList
	expressionList, err = newFilterQuery(params.Criteria)
	if err != nil {
		return
	}

	queryNext := goqu.And(goqu.C(params.CursorName).Gt(params.EndCursor))
	queryPrev := goqu.And(goqu.C(params.CursorName).Lt(params.StartCursor))
	if expressionList != nil && !expressionList.IsEmpty() {
		queryNext = queryNext.Append(expressionList)
		queryPrev = queryPrev.Append(expressionList)
	}
	type result struct {
		HasNext     bool `db:"has_next"`
		HasPrevious bool `db:"has_prev"`
	}
	nextSubQuery := params.DB.From(params.Table).
		Select(goqu.L("1")).
		Where(queryNext).
		Limit(1)
	prevSubQuery := params.DB.From(params.Table).
		Select(goqu.L("1")).
		Where(queryPrev).
		Limit(1)
	res := result{}
	_, err = params.DB.Select(
		goqu.L("EXISTS(?) AS has_next", nextSubQuery),
		goqu.L("EXISTS(?) AS has_prev", prevSubQuery),
	).ScanStructContext(ctx, &res)
	if err != nil {
		return
	}
	return res.HasPrevious, res.HasNext, nil
}
